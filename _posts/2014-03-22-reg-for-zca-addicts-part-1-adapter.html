---
author: kagesenshi
blogger_id: tag:blogger.com,1999:blog-28371165.post-3128117436084145256
blogger_orig_url: https://blog.kagesenshi.org/2014/03/reg-for-zca-addicts-part-1-adapter.html
categories:
- old blog
date: '2014-03-22T08:52:00.001+08:00'
layout: post
modified_time: '2014-03-22T10:10:49.231+08:00'
tags:
- Guide
- Grok
- Reg
- PlanetFedora
- Python
- Open Source
- Hacks
- HOWTO
- PlanetPlone
- Zope
title: 'Reg for ZCA addicts - Part 1: Adapter'
---

<div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on">Recently I have been exploring <a href="http://reg.readthedocs.org/">Reg</a>, a library inspired by <a href="http://docs.zope.org/zope.component/">zope.component </a>written by Faassen, and I found its simplification of ZCA to be pretty interesting. Being really loving ZCA for a while now, I end up trying to figure out how the ZCA patterns fits if I were to use Reg in my future projects. So here are the list of items I discovered so far:<br /><br /><b>Adapters</b><br />This is the most common pattern I use with ZCA, primarily to simplify writing logic by standardizing the interface of objects I work with into a common set of behavior/functions:<br /><br />In ZCA , adapters are done this way:<br /><br /><pre>from zope import interface<br />from zope import component<br /><br />class IDog(interface.Interface):<br />    def bark():<br />        pass<br /><br />class Dog(object):<br />    interface.implements(IDog)<br /><br />    def bark(self):<br />        return 'Woof'<br /><br />class IDuck(interface.Interface):<br />    def quack():<br />        pass<br /><br />class Duck(object):<br />    interface.implements(IDuck)<br /><br />    def quack(self):<br />        return 'Quack'<br /><br />class IAnimalSoundAdapter(interface.Interface):<br />    def make_sound():<br />        pass<br /><br />class DogSoundAdapter(grok.Adapter):<br />    interface.implements(IAnimalAdapter)<br />    interface.adapts(IDog) <br /><br />    def __init__(self, dog):<br />        self._dog = dog<br /><br />    def make_sound(self):<br />        return self._dog.bark()<br /><br />class DuckSoundAdapter(grok.Adapter):<br />    interface.implements(IAnimalSoundAdapter)<br />    interface.adapts(IDuck)<br /><br />    def __init__(self, duck):<br />        self._duck = duck<br /><br />    def make_sound(self):<br />        return self._duck.quack()<br /><br />gsm = component.getGlobalSiteManager()<br />gsm.registerAdapter(DogSoundAdapter, (IDog,), IAnimalSoundAdapter)<br />gsm.registerAdapter(DuckSoundAdapter, (IDuck,), IAnimalSoundAdapter)<br /><br />dog = Dog()<br />duck = Duck()<br /><br />dog.bark() # Woof<br />duck.quack() # Quack<br /><br />IAnimalSoundAdapter(dog).make_sound() # Woof<br />IAnimalSoundAdapter(duck).make_sound() # Quack<br /></pre><br />And that is quite a code, which utilizes classes, and large external interfaces libraries and component libraries which might can make many pythonistas cringe.&nbsp; <br /><br />In Reg, things are simplified. Similar functionality is done not through interfaces and complex object/class markers, but through simple functions. Reg adapter interfaces are simply functions:<br /><br /></div><pre>import reg<br />import reg.implicit<br /><br /><br />class Dog(object):<br />    def bark(self):<br />        return 'Woof'<br /><br />class Duck(object):<br />    def quack(self):<br />        return 'Quack'<br /><br />@reg.generic<br />def make_sound(obj):<br />    raise NotImplementedError<br /><br />def dog_sound(dog):<br />    return dog.bark()<br /><br />def duck_sound(duck):<br />    return duck.quack()<br /><br />registry = reg.Registry()<br />reg.implicit.initialize(registry)<br /><br />registry.register(make_sound, [Dog], dog_sound)<br />registry.register(make_sound, [Duck], duck_sound)<br /><br />dog = Dog()<br />duck = Duck()<br /><br />make_sound(dog) # Woof<br />make_sound(duck) # Quack</pre></div><br />Now, ZCA users might shout by now, "I want class based adapters!" (I know I did). This is how it can be implemented in Reg:<br /><br /><pre>import reg<br />import reg.implicit<br /><br />class Dog(object):<br />    def bark(self):<br />        return 'Woof'<br /><br />class Duck(object):<br />    def quack(self):<br />        return 'Quack'<br /><br />@reg.generic<br />def animal_sound_adapter(obj):<br />    raise NotImplementedError<br /><br />class DogSoundAdapter(object):<br /><br />    def __init__(self, dog):<br />        self._dog = dog<br /><br />    def make_sound(self):<br />        return self._dog.bark()<br /><br />class DuckSoundAdapter(object):<br /><br />    def __init__(self, duck):<br />        self._duck = duck<br /><br />    def make_sound(self):<br />        return self._duck.quack() <br /><br />registry = reg.Registry()<br />reg.implicit.initialize(registry)<br /><br />registry.register(animal_sound_adapter, [Dog], DogSoundAdapter)<br />registry.register(animal_sound_adapter, [Duck], DuckSoundAdapter)<br /><br />dog = Dog()<br />duck = Duck()<br /><br />animal_sound_adapter(dog).make_sound() # Woof<br />animal_sound_adapter(duck).make_sound() # Quack</pre></div><br />Thats it for now, next one I will probably share about multiadapters on Reg.<br /><div class="blogger-post-footer"><br/>
<br/>
- Izhar Firdaus -</div>